// SPDX-License-Identifier: MIT

pragma solidity ^0.8.15;


contract OperatorRegistry {
    error OperatorsNotCommitted();
    error OperatorMaxValidatorsReached();
    error OperatorNotCommitted();
    error MaxValidatorError();
    error InvalidOperator();
    error ValidatorPreviouslyRegistered();
    error NotAuthorized();

    event OperatorCommited(address indexed operator);
    event OperatorUncommited(address indexed operator);
    event OperatorRemoved(address indexed operator);
    event OperatorMaxValidatorsSet(address indexed operator, uint256 maxValidators);

    /// @dev Node Operator parameters and internal state
    struct Operator {
        bool commited; // a flag indicating if the operator can participate in further staking
        uint64 maxValidators; // the maximum number of validators to stake for this operator
        uint64 validatorsActive; // number of active validators for this operator
    }

    /**
     * @dev Structure for passing information about the validator deposit data.
     * @param operator - address of the operator.
     * @param pubkey - BLS public key of the validator, generated by the operator.
     * @param withdrawal_credentials - withdrawal credentials used for generating the deposit data.
     * @param signature - BLS signature of the validator, generated by the operator.
     * @param deposit_data_root - hash tree root of the deposit data, generated by the operator.
     */
    struct ValidatorData {
        address operator;
        bytes pubkey;
        bytes32 withdrawal_credentials;
        bytes signature;
        bytes32 deposit_data_root; // more efficient to be calculated off-chain
    }

    uint256 public totalValidators;

    // Maps address to authorized Keepers
    mapping(address => bool) public keepers;

    // Maps address to Operator data
    mapping(address => Operator) public operators;

    // Maps hash of the validator data to whether it is registered.
    mapping(bytes32 => bool) public validators;

    
    modifier onlyKeeper() {
        if (!keepers[msg.sender]) revert NotAuthorized();
        _;
    }

    function commitOperator(address newOperator) external onlyKeeper {
        if (newOperator == address(0)) revert InvalidOperator();
        Operator storage operator = operators[newOperator];

        operator.commited = true;

        emit OperatorCommited(newOperator);
    }

    function uncommitOperator(address operator) external onlyKeeper {
        if (operator == address(0)) revert InvalidOperator();
        Operator storage operatorToUncommit = operators[operator];

        operatorToUncommit.commited = false;

        emit OperatorUncommited(operator);
    }

    function removeOperator(address operator) external onlyKeeper {
        delete operators[operator];

        emit OperatorRemoved(operator);
    }

    function setMaxValidators(address operator, uint64 maxValidators) external onlyKeeper {
        Operator storage op = operators[operator];
        if (!op.commited) revert OperatorNotCommitted();
        if (op.validatorsActive > maxValidators) revert MaxValidatorError();

        op.maxValidators = maxValidators;

        emit OperatorMaxValidatorsSet(operator, maxValidators);
    }

    /**
     * @notice This function is used to register a validator with the contract.
     * @dev The function takes in a ValidatorData calldata depositData as an argument. This data is used to register the validator with the contract.
     */
    function registerValidator(ValidatorData calldata depositData) internal {
        Operator storage op = operators[depositData.operator];

        if (!op.commited) revert OperatorsNotCommitted();
        if (op.validatorsActive + 1 > op.maxValidators) {
            revert OperatorMaxValidatorsReached();
        }

        // mark validator as registered -> prevents from registering the same validator twice
        bytes32 validatorId = keccak256(abi.encode(depositData.pubkey));

        if (validators[validatorId]) revert ValidatorPreviouslyRegistered();

        validators[validatorId] = true;
        op.validatorsActive++;
        totalValidators++;
    }
}
