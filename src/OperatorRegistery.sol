// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import {TwoStepOwnable} from "./auth/TwoStepOwnable.sol";
import {IOperatorRegistery} from "./interfaces/IOperatorRegistery.sol";

contract OperatorRegistery is IOperatorRegistery, TwoStepOwnable {
    error OperatorsNotCommitted();
    error OperatorMaxValidatorsReached();

    /// @dev Node Operator parameters and internal state. All these are in the interface
    // struct Operator {
    //     bool commited; // a flag indicating if the operator can participate in further staking
    //     uint64 maxValidators; // the maximum number of validators to stake for this operator
    //     uint64 validatorsActive; // number of active validators for this operator
    // }

    // /**
    //  * @dev Structure for passing information about the validator deposit data.
    //  * @param operator - address of the operator.
    //  * @param pubkey - BLS public key of the validator, generated by the operator.
    //  * @param withdrawal_credentials - withdrawal credentials used for generating the deposit data.
    //  * @param signature - BLS signature of the validator, generated by the operator.
    //  * @param deposit_data_root - hash tree root of the deposit data, generated by the operator.
    //  */
    // struct ValidatorData {
    //     address operator;
    //     bytes pubkey;
    //     bytes withdrawal_credentials;
    //     bytes signature;
    //     bytes32 deposit_data_root; // more efficient to be calculated off-chain
    // }

    uint256 public totalValidators;
    address public manifoldLSD;

    mapping(address => Operator) public operators;

    // Maps hash of the validator data to whether it is registered.
    mapping(bytes32 => bool) public validators;

    // todo: maybe make a "Guardians" contract
    // that has all the owners and roles that's deployed
    // separately so we dont have to keep instantiating this stuff
    modifier onlyManifoldLSD() {
        if (msg.sender != manifoldLSD) revert();
        _;
    }

    constructor(address _manifoldLSD) {
        // todo: maybe make this a param
        _initializeOwner(msg.sender);
        manifoldLSD = _manifoldLSD;
    }

    function commitOperator(address newOperator) external onlyOwner {
        require(newOperator != address(0), "invalid newOperator");
        Operator storage operator = operators[newOperator];

        operator.commited = true;

        // todo: emit event
    }

    function uncommitOperator(address newOperator) external onlyOwner {
        require(newOperator != address(0), "invalid newOperator");
        Operator storage operator = operators[newOperator];

        operator.commited = false;

        // todo: emit event
    }

    /**
     * @dev See {IPoolValidators-removeOperator}.
     */
    function removeOperator(address operator) external onlyOwner {
        delete operators[operator];

        // todo: emit event
    }

    error OperatorNotCommitted();
    error MaxValidatorError();

    function setMaxValidators(
        address operator,
        uint64 maxValidators
    ) external onlyOwner {
        Operator storage op = operators[operator];
        if (!op.commited) revert OperatorNotCommitted();
        if (op.validatorsActive > maxValidators) revert MaxValidatorError();

        op.maxValidators = maxValidators;

        // todo: emit event
    }

    function operatorCommitted(address operator) public view returns (bool) {
        return operators[operator].commited;
    }

    function registerValidator(
        ValidatorData calldata depositData
    ) external onlyManifoldLSD {
        Operator storage op = operators[depositData.operator];

        if (!op.commited) revert OperatorsNotCommitted();
        if (op.validatorsActive + 1 > op.maxValidators)
            revert OperatorMaxValidatorsReached();

        // mark validator as registered -> prevents from registering the same validator twice
        bytes32 validatorId = keccak256(abi.encode(depositData.pubkey));
        require(!validators[validatorId], "validator already registered");

        validators[validatorId] = true;
        op.validatorsActive++;
        totalValidators++;

        // todo: emit event
    }
}
